#+TITLE: DPom
#+DESCRIPTION: my specific functions and commands
#+STARTUP: overview

* Implementation

I split the package in 2 parts:
- utils :: utility functions load with =required=
- commands :: commands load with =autoload=

** Utils
*** coding-hook functions
These belong in coding-hook:

We have a number of turn-on-* functions since it's advised that lambda
functions not go in hooks. Repeatedly evaling an add-to-list with a
hook value will repeatedly add it since there's no way to ensure
that a lambda doesn't already exist in the list.
#+name: coding-hook
#+begin_src emacs-lisp
(defun local-column-number-mode ()
  (make-local-variable 'column-number-mode)
  (column-number-mode t))

(defun local-comment-auto-fill ()
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))

(defun turn-on-hl-line-mode ()
  (if window-system (hl-line-mode t)))

(defun turn-on-save-place-mode ()
  (setq save-place t))

(defun turn-on-whitespace ()
  (whitespace-mode t))

(defun turn-off-tool-bar ()
  (tool-bar-mode -1))
#+end_src

*** org
#+name: org-utils
#+begin_src emacs-lisp
  (defun dpom-clock-in-to-started (kw)
  "Switch task from TODO to STARTED when clocking in.
  Skips capture tasks and tasks with subtasks"
  (if (and (string-equal kw "TODO")
           (not (and (boundp 'org-capture-mode) org-capture-mode)))
      (let ((subtree-end (save-excursion (org-end-of-subtree t)))
            (has-subtask nil))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-not-done-keywords)
              (setq has-subtask t))))
        (when (not has-subtask)
          "STARTED"))))
#+end_src

*** csv
#+name: csv-utils
#+begin_src emacs-lisp
(defun dpom-csv-buffer-to-list ()
  "Return a list wich elements are current buffer lines starting from point"
  (let (result start)
    (while (not (eobp))
      (setq start (line-beginning-position))
      (end-of-line)
      (setq result (append result (list
                                   (buffer-substring-no-properties
                                    start (point)))))
      (forward-line 1))
    result))


(defun dpom-csv-to-list (&optional sep)
  "Convert a csv buffer in a list. Each element of the list is a
  list containing csv fields."
  (mapcar #'(lambda (x)
              (split-string x (or sep ",")))
          (dpom-csv-buffer-to-list)))


(defun dpom-csv-file-to-list (file &optional separator)
    "Convert a csv file FILE in a list. Each element of the list is a
  list containing csv fields."
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (dpom-csv-to-list separator)))


(defsubst dpom-csv-string-trim (string seq)
  "Lose leading and trailing whitespace.  Also remove all properties
from string."
  (if (string-match (concat "\\`[" seq "]+") string)
      (setq string (substring string (match-end 0))))
  (if (string-match (concat "[" seq "]+\\'") string)
      (setq string (substring string 0 (match-beginning 0))))
  (set-text-properties 0 (length string) nil string)
  string)
#+end_src

*** Utils Main Block

#+name: dpom-utils
#+begin_src emacs-lisp :tangle dpom-utils.el :padline no :noweb yes :results silent
<<coding-hook>>
<<org-utils>>
<<csv-utils>>

(provide 'dpom-utils)
#+end_src
** Commands
*** Custom variables
In order to find more easy my  custom variables I define a group =dpom=:

#+name: custom-variables
#+begin_src emacs-lisp
  (defgroup dpom nil
    "My custom variables"
    :version "1.0"
    :group 'tool)

  (defcustom  dpom-doc-dir "~/pers/doc/"
    "Documentation repository"
    :type '(string)
    :group 'dpom)
#+end_src

*** Global commands
#+name: global-comands
#+begin_src emacs-lisp
  ;;;###autoload
  (defun dpom-insert-day ()
    "Insert a day using calendar"
    (interactive)
    (require 'org)
    (insert (format "%s" (org-read-date nil nil nil "Day"))))

  ;;;###autoload
  (defun dpom-comment-or-uncomment-current-line-or-region ()
    "Comments or uncomments current current line or whole lines in region."
    (interactive)
    (save-excursion
      (let (min max)
        (if (and transient-mark-mode mark-active)
            (setq min (region-beginning) max (region-end))
          (setq min (point) max (point)))
        (comment-or-uncomment-region
         (progn (goto-char min) (line-beginning-position))
         (progn (goto-char max) (line-end-position))))))

  ;;;###autoload
  (defun dpom-get-doc-file ()
    "Find a a doc file using."
    (interactive)
    (let ((doc (completing-read "Choose document: "
                                    (mapcar  'file-name-sans-extension  (directory-files dpom-doc-dir nil ".*\.org$"))
                                    nil t)))
      (when doc
        (find-file (expand-file-name (concat doc ".org") dpom-doc-dir)))))

  ;;;###autoload
  (defun dpom-eshell-execute-current-line ()
    "Insert text of current line in eshell and execute."
    (interactive)
    (require 'eshell)
    (let ((command (buffer-substring
                    (save-excursion
                      (beginning-of-line)
                      (point))
                    (save-excursion
                      (end-of-line)
                      (point)))))
      (let ((buf (current-buffer)))
        (unless (get-buffer eshell-buffer-name)
          (eshell))
        (display-buffer eshell-buffer-name t)
        (switch-to-buffer-other-window eshell-buffer-name)
        (goto-char (point-max))
        (eshell-kill-input)
        (insert command)
        (eshell-send-input)
        (goto-char (point-max))
        (switch-to-buffer-other-window buf))))

    ;;;###autoload
  (defun untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

    ;;;###autoload
  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

    ;;;###autoload
  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (indent-buffer)
    (untabify-buffer)
    (delete-trailing-whitespace))

  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  ;; (defun eval-and-replace (value)
  ;;   "Evaluate the sexp at point and replace it with its value"
  ;;   (interactive (list (eval-last-sexp nil)))
  ;;   (kill-sexp -1)
  ;;   (insert (format "%S" value)))

  ;; Cosmetic

    ;;;###autoload
  (defun pretty-lambdas ()
    (font-lock-add-keywords
     nil `(("(?\\(lambda\\>\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,(make-char 'greek-iso8859-7 107))
                      nil))))))


    ;;;###autoload
  (defun sudo-edit (&optional arg)
    (interactive "p")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:" (read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  ;; A monkeypatch to cause annotate to ignore whitespace
    ;;;###autoload
  (defun vc-git-annotate-command (file buf &optional rev)
    (let ((name (file-relative-name file)))
      (vc-git-command buf 0 name "blame" "-w" rev)))


    ;;;###autoload
  (defun sm-try-smerge ()
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^<<<<<<< " nil t)
        (smerge-mode 1))))
#+end_src

*** Tags
#+name: tags
#+begin_src emacs-lisp
  ;;;###autoload
  (defun dpom-create-tags (dir-name)
      "Create tags file."
      (interactive "DDirectory: ")
      (shell-command
       (format "%s -f %s/TAGS -e -R %s" "/usr/bin/ctags"  dir-name (directory-file-name dir-name)))
    )
#+end_src
*** Org
#+name: org-commands
#+begin_src emacs-lisp
  ;;;###autoload
(defun dpom-org-surround-block (beg end &optional tag)
  (interactive "r")
  (if (not tag) (setq tag (read-string "type: ")))
  (save-restriction
    (narrow-to-region beg end)
    (goto-char (point-min))
    (insert "#+begin_" tag "\n")
    (goto-char (point-max))
    (insert "#+end_" tag "\n")))

  ;;;###autoload
(defun dpom-org-surround-src (beg end)
  (interactive "r")
  (dpom-org-surround-block beg end "src"))

  ;;;###autoload
(defun dpom-babel (beg end)
  (interactive "r")
  (babel-region beg end t))

  ;;;###autoload
(defun dpom-org-surround-example (beg end)
  (interactive "r")
  (dpom-org-surround-block beg end "example"))

  ;;;###autoload
(defun bh/org-agenda-to-appt ()
  "Erase all reminders and rebuilt reminders for today from the agenda"
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

  ;;;###autoload
(defun dpom-org-manual ()
  (interactive)
  (info "~/.emacs.d/info/org"))

  ;;;###autoload
(defun dpom-screenshot ()
  "Take a screenshot into a unique-named file in the current buffer file
  directory and insert a link to this file."
  (interactive)
  (let ((filename (concat (make-temp-name (file-name-directory (buffer-file-name))) ".jpg" )))
    (call-process "import" nil nil nil filename)
    (insert (concat "[[" filename "]]"))
    (org-display-inline-images)))


;;;###autoload
(defun dpom-insert-file-as-org-table (filename)
  "Insert a csv file (; separator) into the current buffer at point, and convert it to an org table."
  (interactive (list (read-file-name "csv file: ")))
  (let* ((start (point))
         (end (+ start (nth 1 (insert-file-contents filename)))))
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (while (search-forward ";" nil t) (replace-match "|"))
      )
    (org-table-convert-region start end)
    ))
#+end_src

**** detangle

#+name: org-detangle
#+begin_src emacs-lisp
;;;###autoload
(defun dpom-org-babel-detangle (&optional source-code-file)
  "Propagate changes in source file back original to Org-mode file.
This requires that code blocks were tangled with link comments
which enable the original code blocks to be found."
  (interactive)
  (save-excursion
    (when source-code-file (find-file source-code-file))
    (message "detangled %d code blocks" (dpom-org-babel-detangle-region (point-min) (point-max)))))


(defun dpom-org-babel-detangle-region (beg end)
  (save-excursion
    (goto-char beg)
    (let ((counter 0) new-body start next)
      (while (re-search-forward org-bracket-link-analytic-regexp end t)
        (setq start (match-end 0))
        (when (re-search-forward (concat " " (regexp-quote (match-string 5)) " ends here"))
          (setq next (match-end 0))
          (forward-line -1)
          (if (dpom-org-babel-contain-embedded-src-p start next)
              (setq counter (+ counter (dpom-org-babel-detangle-region start next)))
            (save-excursion
              (when (setq new-body (org-babel-tangle-jump-to-org))
                (org-babel-update-block-body new-body)
                (setq counter (+ 1 counter))))))
          (goto-char next))
      counter)))


(defun dpom-org-babel-contain-embedded-src-p (beg end)
  "Return true if there are source blocks embedded."
  (save-excursion
      (goto-char beg)
      (if (re-search-forward org-bracket-link-analytic-regexp end t) t nil)))

(defun dpom-test-org-babel-contain-embedded-src-p (beg end)
  (interactive "r")
  (message "dpom-org-babel-contain-embedded-src-p result: %s" (dpom-org-babel-contain-embedded-src-p beg end)))
#+end_src

**** org-e-contacts

Scopul acestei comenzi este de a converti fisierul contacts.org intr-un fisier csv  importabil in google contacts. Am folosit noul framework de export de la org. Este ok, singura observatie este cu privire la macro-ul =org-export-define-backend= care merge evaluat decat o singura data intr-o sesiune, daca il modific trebuie sa repornesc emacs ca sa ia in considerare modificarile.

Referinte:
1. [[http://orgmode.org/worg/dev/org-export-reference.html][Org Export Reference Documentation]]
2. [[file:~/pers/projects/other/org-mode/contrib/lisp/org-e-ascii.el][org-e-ascii]]
3. [[http://support.google.com/mail/bin/answer.py?hl%3Den&answer%3D14024][Importing CSV files
]]

#+name: org-e-contacts
#+begin_src emacs-lisp :tangle org-e-contacts.el :padline no :noweb yes :results silent
(require 'org-export)
(require 'org-e-ascii)

(org-export-define-backend e-contacts
  (
   (headline . org-e-contacts-headline)
   (property-drawer . org-e-contacts-property-drawer)
   (section . org-e-contacts-section)
   (template . org-e-contacts-template)
   :export-block "ASCII"
   :filters-alist ((:filter-headline . org-e-contacts-filter-headline-blank-lines)
                   (:filter-section . org-e-contacts-filter-section-blank-lines))
   ))

(defun org-e-contacts-section (section contents info)
  "Transcode a SECTION element from Org to csv.
CONTENTS holds the contents of the section.  INFO is a plist
holding contextual information."
  contents)


(defun org-e-contacts-headline (headline contents info)
  "Transcode an HEADLINE element from Org to csv.
CONTENTS holds the contents of the headline.  INFO is a plist
holding contextual information."
  (let ((level (org-element-property :level headline)))
    (concat
     (if (= level 2) (concat (org-element-property :raw-value headline) ","))
     contents)))

(defun org-e-contacts-template (contents info)
  "Return complete document string after contacts conversion.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options."
  (org-element-normalize-string
   (concat
    "name,E-mail Address,Home Address,Mobile Phone\n"
    ;; Document's body.
     contents)))

(defun org-e-contacts-property-drawer (property-drawer contents info)
  "Transcode a PROPERTY-DRAWER element from Org to LaTeX.
CONTENTS is nil.  INFO is a plist holding contextual
information."
  (let ((props (org-element-property :properties property-drawer)))
    (concat (cdr (assoc "EMAIL" props)) ","
            (cdr (assoc "ADDRESS" props)) ","
            (cdr (assoc "PHONE_MOBILE" props)) "\n")))


(defun org-e-contacts-filter-headline-blank-lines (headline back-end info)
  "Filter controlling number of blank lines after an headline.
This function only applies to `e-contacts' back-end.
For any other back-end, HEADLINE is returned as-is."
  (if (not (eq back-end 'e-contacts)) headline
    (replace-regexp-in-string "\n\\(?:\n[ \t]*\\)*\\'" ?\n headline)))

(defun org-e-contacts-filter-section-blank-lines (section back-end info)
  "Filter controlling number of blank lines after an headline.
This function only applies to `e-contacts' back-end.
For any other back-end, HEADLINE is returned as-is."
  (if (not (eq back-end 'e-contacts)) section
    (replace-regexp-in-string "\n\\(?:\n[ \t]*\\)*\\'" "" section)))



(defun org-e-contacts-export-as-csv
  (&optional subtreep visible-only body-only ext-plist)
  "Export current buffer to a csv buffer.

If narrowing is active in the current buffer, only export its
narrowed part.

If a region is active, export that region.

When optional argument SUBTREEP is non-nil, export the sub-tree
at point, extracting information from the headline properties
first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

When optional argument BODY-ONLY is non-nil, strip title, table
of contents and footnote definitions from output.

EXT-PLIST, when provided, is a property list with external
parameters overriding Org default settings, but still inferior to
file-local settings.

Export is done in a buffer named \"*Org E-CONTACTS Export*\", which
will be displayed when `org-export-show-temporary-export-buffer'
is non-nil."
  (interactive)
  (let ((outbuf (org-export-to-buffer
                 'e-contacts "*Org E-CONTACTS Export*"
                 subtreep visible-only body-only ext-plist)))
    (with-current-buffer outbuf (text-mode))
    (when org-export-show-temporary-export-buffer
      (switch-to-buffer-other-window outbuf))))

(defun org-e-contacts-export-to-csv
  (&optional subtreep visible-only body-only ext-plist pub-dir)
  "Export current buffer to a csv file.

If narrowing is active in the current buffer, only export its
narrowed part.

If a region is active, export that region.

When optional argument SUBTREEP is non-nil, export the sub-tree
at point, extracting information from the headline properties
first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

When optional argument BODY-ONLY is non-nil, strip title, table
of contents and footnote definitions from output.

EXT-PLIST, when provided, is a property list with external
parameters overriding Org default settings, but still inferior to
file-local settings.

When optional argument PUB-DIR is set, use it as the publishing
directory.

Return output file's name."
  (interactive)
  (let ((outfile (org-export-output-file-name ".csv" subtreep pub-dir)))
    (org-export-to-file
     'e-contacts outfile subtreep visible-only body-only ext-plist)))




(provide 'org-e-contacts)

;; test

;; (progn
;;  (setq org-export-show-temporary-export-buffer t)
;;  (set-buffer (find-file dpom-org-contacts-file))
;;  (goto-char (point-min))
;;  (org-e-contacts-export-as-csv))
#+end_src

*** Lisp
#+name: lisp-commands
#+begin_src emacs-lisp
;(require 'slime-autoloads)

;;;###autoload
(defun dpom-check-region-parens ()
  "Check if parentheses in the region are balanced. Signals a
scan-error if not."
  (interactive)
  (save-restriction
    (save-excursion
    (let ((deactivate-mark nil))
      (condition-case c
          (progn
            (narrow-to-region (region-beginning) (region-end))
            (goto-char (point-min))
            (while (/= 0 (- (point)
                            (forward-list))))
            t)
        (scan-error (signal 'scan-error '("Region parentheses not balanced"))))))))


;;;###autoload
(defun dpom-remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (make-local-variable 'after-save-hook)
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))))
#+end_src

*** XML

#+name: xml-commands
#+begin_src emacs-lisp
(defcustom dpom-xml-schema-list ()
  "Validation schema list"
  :type 'list
  :group 'dpom)

(defvar dpom-log-buffer (concat "*Dpom-Log*")
  "Log buffer")

;;;###autoload
(defun dpom-format-xml (arg)
  (interactive "P")
  "Entry point for xml formating commands. Without an argument
nice indent the xml file, with argument compact it"
  (if (null arg) (dpom-indent-xml) (dpom-compact-xml)))

(defun dpom-compact-xml (&optional file)
  "Suppress all white spaces between > and < from the current buffer"
  (goto-char (point-min))
  (while (re-search-forward ">[ \n\t]*<" nil t)
    (replace-match "><" nil nil)))


(defun dpom-indent-xml (&optional file)
  "Prety indent the current xml buffer"
  (goto-char (point-min))
  (while (re-search-forward "><" nil t)
    (replace-match ">\n<" nil nil))
  (goto-char (point-min))
  (while (not (= (point) (point-max)))
    (indent-for-tab-command)
    (forward-line)))

;;;###autoload
(defun dpom-complete-surround-tag (beg end)
  (interactive "r")
  (let ((tag (read-string "tag: ")))
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (insert "<" tag ">\n")
      (goto-char (point-max))
      (insert "</" tag ">\n"))))

;;;###autoload
(defun dpom-get-xpath (&optional print-message)
  "Return all the elements in the ancestor axis of the current
    element.  If called interactively, show it in the echo area."
  (interactive "p")
  (nxml-ensure-scan-up-to-date)
  (let ((path (mapconcat #'(lambda (x) x) (xml-remove-complete-elements (xml-get-tags (current-buffer) (point))) "/")))
    (when print-message
      (message "%s" path))
    (kill-new path)
    path))


(defun xml-get-tags (buf pos)
  "Get all start/end tags from begining of BUF till POS."
    (set-buffer buf)
    (goto-char pos)
    (setq pos (search-forward ">"))
    (goto-char (point-min))
    (let ((ellist ()))
      (while (and (re-search-forward "<\\([^?]/?[a-z-A-Z]*\\)" nil t)
                  (< (point) pos))
        (setq ellist (cons (substring-no-properties (match-string 1)) ellist)))
      ellist))

(defun xml-remove-complete-elements (lst)
  "Remove complete elements start/end tags from LST."
  (let ((acc ())
        (tag nil))
    (mapc #'(lambda (x)
              (if (null tag)
                  (if (equal ?/ (elt x 0)) (setq tag (substring x 1))(setq acc (cons x acc)))
                (if (string= tag x) (setq tag nil))))
          lst)
    acc))



;; add msv to the systems list for the error alist creation
(defvar compilation-error-regexp-alist-alist)
(defvar compilation-error-regexp-alist)
(defvar msv-error-regexp
  '(msv "^\\(Fatal \\)?[Ee]rror at line:\\([0-9,]+\\), column:\\([0-9]+\\) of file:\\(.+\\)" 4 2 3))

(unless (assq 'msv  compilation-error-regexp-alist-alist)
  (setq compilation-error-regexp-alist-alist (cons msv-error-regexp compilation-error-regexp-alist-alist)))

(setq compilation-error-regexp-alist (mapcar 'car compilation-error-regexp-alist-alist))



;;;###autoload
(defun dpom-validate-xml (&optional file)
  "Validate current xml buffer"
  (interactive)
  (if (null file) (setq file (file-name-nondirectory buffer-file-name)))
  (compile (concat "xmlValidate"
                   " " (expand-file-name (cdr (assoc (completing-read "Schema: " dpom-xml-schema-list)
                                                     dpom-xml-schema-list)))
                   " " (expand-file-name file)) t))

;;;###autoload
(defun dpom-use-xsl-with-outfile (&optional file)
  "Use the actual xsl buffer or the FILE to transform an xml file.
The result is saved in a file."
  (interactive)
  (if (null file) (setq file (file-name-nondirectory buffer-file-name)))
  (compile (concat "xmlTransform"
                   " " (expand-file-name file)
                   " " (expand-file-name (read-file-name "Xml file: "))
                   " " (expand-file-name (read-file-name "Output file: ")))
                    t))

;;;###autoload
(defun dpom-use-xsl (&optional file)
  "Use the actual xsl buffer or the FILE to transform an xml file."
  (interactive)
  (if (null file) (setq file (file-name-nondirectory buffer-file-name)))
  (compile (concat "xmlTransform"
                   " " (expand-file-name file)
                   " " (expand-file-name (read-file-name "Xml file: ")))
                    t))



(defun dpom-log (log &rest args)
  "Log a message or the contents of a buffer.
If LOG is a string and there are more args, it is formatted with
those ARGS.  Usually the LOG string ends with a \n.  End each
bunch of errors with (dpom-log t): this inserts the current time
and buffer at the start of the page, and \f (formfeed) at the
end."
  (let ((obuf (current-buffer)))
    (with-current-buffer (get-buffer-create dpom-log-buffer)
      (goto-char (point-max))
      (let ((inhibit-read-only t))
        (cond ((stringp log)
               (insert (if args
                           (apply (function format) log args)
                         log)))
              ((bufferp log)
               (insert-buffer-substring log))
              ((eq t log)
               (goto-char (point-max))
               (insert "\n\n")
               (insert (current-time-string) "\n")))
          (sit-for 0)))))
#+end_src

*** Translate
 I need a command to in-line translate. It should works on selected region or last word if it isn't a selection and should replace the selected text with the translation.

#+name: translate-commands
#+begin_src emacs-lisp
  (require 'url-handlers)

  (defun babel-url-retrieve (url)  ;; return a buffer
    (let* ((url-show-status nil)
           (tmp (url-retrieve-synchronously url)))
      (unless (cadr (url-insert tmp))
        (mm-decode-coding-region (point-min) (point-max) 'utf-8))
      (kill-buffer tmp)))

  (babel-url-retrieve "http://translate.google.com/#ro|en|acasa")
#+end_src

aceasta traducere

*** Commands Main Block
#+name: dpom-commands
#+begin_src emacs-lisp :tangle dpom-commands.el :padline no :noweb yes :results silent
(require 'dpom-utils)
(require 'esh-mode)
(require 'eshell)
(require 'org)
(require 'imenu)
(require 'thingatpt)

<<custom-variables>>
<<global-comands>>
<<tags>>
<<org-commands>>
<<org-detangle>>
<<lisp-commands>>
<<xml-commands>>

(provide 'dpom-commands)
#+end_src


* Tasks
** TODO [#C] study the setup example                                       :net:
   SCHEDULED:
                                                                    :PROPERTIES:
   :Effort:   0:30
                                                                    :ID:       1744C4F7-FFC2-4E2D-B798-25B2D3F00026
                                                                           :END:
   #+begin_src emacs-lisp
;; emacs setup

(add-to-list 'load-path "~/.emacs.d/el-get/el-get")
(require 'el-get)
(setq
 el-get-sources
 '(el-get
   php-mode-improved
   psvn
   auto-complete
   switch-window

   (:name buffer-move
          :after (lambda ()
                   (global-set-key (kbd "<C-S-up>")     'buf-move-up)
                   (global-set-key (kbd "<C-S-down>")   'buf-move-down)
                   (global-set-key (kbd "<C-S-left>")   'buf-move-left)
                   (global-set-key (kbd "<C-S-right>")  'buf-move-right)))

   (:name magit
          :after (lambda ()
                   (global-set-key (kbd "C-x C-z") 'magit-status)))

   (:name goto-last-change
          :after (lambda ()
                   ;; azerty keyboard here, don't use C-x C-/
                   (global-set-key (kbd "C-x C-_") 'goto-last-change)))))

(when window-system
   (add-to-list 'el-get-sources  'color-theme-tango))

(el-get 'sync)

;; visual settings
(setq inhibit-splash-screen t)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(line-number-mode 1)
(column-number-mode 1)

;; Use the clipboard, pretty please, so that copy/paste "works"
(setq x-select-enable-clipboard t)

(set-frame-font "Monospace-10")

(global-hl-line-mode)

;; suivre les changements exterieurs sur les fichiers
(global-auto-revert-mode 1)

;; pour les couleurs dans M-x shell
(autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

;; S-fleches pour changer de fenêtre
(windmove-default-keybindings)
(setq windmove-wrap-around t)

;; find-file-at-point quand ça a du sens
(setq ffap-machine-p-known 'accept) ; no pinging
(setq ffap-url-regexp nil) ; disable URL features in ffap
(setq ffap-ftp-regexp nil) ; disable FTP features in ffap
(define-key global-map (kbd "C-x C-f") 'find-file-at-point)

(require 'ibuffer)
(global-set-key "\C-x\C-b" 'ibuffer)

;; use iswitchb-mode for C-x b
(iswitchb-mode)

;; I can't remember having meant to use C-z as suspend-frame
(global-set-key (kbd "C-z") 'undo)

;; winner-mode pour revenir sur le layout précédent C-c <left>
(winner-mode 1)

;; dired-x pour C-x C-j
(require 'dired-x)

;; full screen
(defun fullscreen ()
  (interactive)
  (set-frame-parameter nil 'fullscreen
                       (if (frame-parameter nil 'fullscreen) nil 'fullboth)))
(global-set-key [f11] 'fullscreen)

   #+end_src
** CANCELLED [#C] See how to remove the insecure link message from w3m :computer:
   SCHEDULED: <2012-03-03 Sat>
                                                                       :LOGBOOK:
   - State "CANCELLED"  from "TODO"       [2012-03-05 Mon 17:02] \\
     nu ma deranjeaza asa de mult
                                                                           :END:
                                                                    :PROPERTIES:
   :Effort:   0:30
                                                                    :ID:       ADCEEA74-F5FE-47DD-A2EF-6B177C95F45C
                                                                           :END:
   [2010-09-29 Wed]
** DONE [#A] export contacts to gogle
SCHEDULED: <2012-08-03 Fri>
:LOGBOOK:
- State "DONE"       from "STARTED"    [2012-08-08 Wed 15:56]
CLOCK: [2012-08-07 Tue 18:58]--[2012-08-07 Tue 19:32] =>  0:34
CLOCK: [2012-08-07 Tue 15:51]--[2012-08-07 Tue 16:14] =>  0:23
CLOCK: [2012-08-07 Tue 15:29]--[2012-08-07 Tue 15:32] =>  0:03
CLOCK: [2012-08-07 Tue 15:12]--[2012-08-07 Tue 15:16] =>  0:04
CLOCK: [2012-08-07 Tue 14:16]--[2012-08-07 Tue 14:48] =>  0:32
CLOCK: [2012-08-07 Tue 13:15]--[2012-08-07 Tue 14:03] =>  0:48
CLOCK: [2012-08-07 Tue 12:18]--[2012-08-07 Tue 12:48] =>  0:30
CLOCK: [2012-08-03 Fri 15:52]--[2012-08-03 Fri 15:56] =>  0:04
CLOCK: [2012-08-03 Fri 14:28]--[2012-08-03 Fri 15:07] =>  0:39
:END:


* COMMENT Setup
  #+STARTUP: logdone
  #+PROPERTY: Effort_ALL  0:10 0:20 0:30 1:00 2:00 4:00 6:00 8:00
  #+COLUMNS: %38ITEM(Details) %TAGS(Context) %7TODO(To Do) %5Effort(Time){:} %6CLOCKSUM{Total}
